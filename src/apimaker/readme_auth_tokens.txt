
table structure
	_id = key, unique key
	des = purpose (optional)
	t,  ak = accesskey, uk = userkey/session_token
	app_id,
	policies, max 5 policies, for eah policy, max 10 records
	ips, max 5 ips
	s, true/false
	max_s,  max sessions 
	expire, ttl index in mongodb, deleted after 10mins of expire time
	max_h,  max hits allowed, -1 infinate
	max_h_m, max hits per minute 
	e, unique event name to identify max events,  ip+event+record+id
	updated, last updated date
	ak_id: optional access_key, when created as sub session
	sess_id: optional  session_key, when user authenticated.
	ip: created for client ip
	hits,  count of hits
	last_ip,
	last_used, date

indexes:
	app_id, key
	app_id, event
	app_id, ip
	app_id, ak_id, ip
	app_id, sess_id

events are useful to identify spamming of tokens. checks to do when generating session tokens at server side
	overall tokens for an ip
		if there are more than 100 tokens for an ip, consider it as a spam
	for login form
		find max events generated for loginevent for the given ip
			find  app_id=app_id and event = ip+'login'
		issue too many requests if there are more than 5 login events from same ip
	for controlling duplicate logins
		delete previous session_token generated by user session id
			user_keys.deletemany("sess_id": session_id)
	for each form action after login
		eventname  =  event+session_id
		find max events generated for same session


access keys are created from:
	auth_control
	engine_api_auth_api
	apis_global_control
	class_engine
	engine Stages
		Generate-Session-Key  by Access Key
		Assume-Session-Key  by role
		Create-Access-Key  entire policy


